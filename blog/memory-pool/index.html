<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="generator" content="Hugo 0.26" />
		<title>Using a Memory Pool to Speed Up String Manipulation - João Pedro Silva</title>

		<meta name="description" content="Lately I&rsquo;ve been trying to learn more about code optimization, specifically how to make code faster. I&rsquo;ve been doing this partly out of frustration from having to deal with slow software on a daily basis, and partly out of curiosity after listening to a bunch of talks and lectures about it by a lot of smart people.
In my research I came accross Agner Fog&rsquo;s Software Optimization Resources, and I&rsquo;ve been slowly making my way through the listed manuals.">


		

		<link  rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway">

		
		<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github-gist.min.css">
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
		
		<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/languages/go.min.js"></script>
		
		

		
		<link rel="stylesheet" href="/css/ui.min.css"/>
		
		<style>
	a { color: #ff8181; }
	blockquote { border-left-color: #ff8181; }
	.bar a:hover {
		color: #ff8181;
		text-decoration: none; }
	.sep {
		margin-top: 2rem;
		margin-bottom: 1rem;
		margin-left:0;
		width: 24rem;
		border-top: 2px solid #ff8181; }
</style>

	</head>

<body>
<header class="container">
	<div class="u-header">
		<nav class="bar">
	<ul><li>
			<a href="/">
				<img class="icon-text" src="/img/prev.svg"/>
			</a>
		</li><li><a href="/blog/">Blog</a></li></ul>
</nav>

	</div>
</header>
<main class="container">

<article>
	<header><hgroup id="brand">
	<h1>Using a Memory Pool to Speed Up String Manipulation</h1>
	<h5>
		<time datetime="2017-09-07 07:40:00 &#43;0100 WEST">Sep 07, 2017</time>
		</h5>
	
</hgroup>
<hr class="sep" />
</header>
	

<p>Lately I&rsquo;ve been trying to learn more about code optimization, specifically how to make code faster. I&rsquo;ve been doing this partly out of frustration from having to deal with slow software on a daily basis, and partly out of curiosity after listening to a bunch of talks and lectures about it by a lot of smart people.</p>

<p>In my research I came accross <a href="http://www.agner.org/optimize/">Agner Fog&rsquo;s Software Optimization Resources</a>, and I&rsquo;ve been slowly making my way through the listed manuals. One of the first concepts I&rsquo;ve come accross while reading <em>&ldquo;Optimizing Software in C++&rdquo;</em> was the notion of memory pooling. This is what <a href="https://en.wikipedia.org/wiki/Memory_pool">Wikipedia</a> has to say about it:</p>

<blockquote>
<p>Memory pools [&hellip;] is the use of pools for memory management that allows dynamic memory allocation comparable to malloc or C++&rsquo;s operator new.</p>

<p>As those implementations suffer from fragmentation because of variable block sizes, it is not recommendable to use them in a real time system due to performance.</p>

<p>A more efficient solution is preallocating a number of memory blocks with the same size called the memory pool.</p>
</blockquote>

<p>In essence, memory pools are a way to mitigate the fact that heap allocations are expensive. By preallocating a block of memory and managing it manually we can reduce the number of allocations necessary drastically, and thus also reduce memory fragmentation.</p>

<p>In this post I&rsquo;ll be going through a very simple implementation of a memory pool meant for storage and manipulation of strings.</p>

<h2 id="why-use-a-string-pool">Why Use a String Pool?</h2>

<p>The usage of a <code>StringPool</code> - a memory pool meant for string storage and manipulation - has a few advantages over the standard <code>std::string</code>:</p>

<ul>
<li>The number of allocations is greatly reduced. With a <code>StringPool</code> allocations only happen when the size of the memory block is no longer sufficient to hold all the strings, as opposed to every time a string is created or modified, as is the case with <code>std::string</code>.</li>
<li>Fragmentation is reduced, decreasing the cost of heap management.</li>
</ul>

<p>Obviously, an alternative is to just use <code>C</code>-style strings. Because <code>C</code> strings are just character arrays, they are very fast and efficient. However, since there is no bounds checking they are also not very secure. A <code>StringPool</code> can be implemented in such a manner that security is not compromised.</p>

<h2 id="implementation">Implementation</h2>

<hr />

<p><strong>DISCLAIMER</strong>: This is a very naive and not very secure implementation of a string pool. It&rsquo;s purpose is purely educational, as in I tried to simplify the examples provided in the <em>&ldquo;Optimizing Software in C++&rdquo;</em> manual as much as I able to, so that I could better internalize the concepts. Hopefully it will help you too.</p>

<p>Full credit goes to Agner Fog for the original implementation I based this post on. If you are looking for a far better implementation then go check it out.</p>

<hr />

<p>In the particular implementation of a <code>StringPool</code> that I&rsquo;ll be going through in this section, each string is identified by a number, or <code>Index</code>. These identifiers don&rsquo;t have to be sequential, but all skipped numbers will be assigned the empty string. Additionaly, the length of each string is stored along it&rsquo;s content, in order to avoid expensive calls to <code>strlen</code>.</p>

<p>The <code>StringPool</code> also supports a small number of operations. Those are <strong>access</strong>, <strong>insertion</strong> and <strong>concatenation</strong>. Basic usage looks like the following:</p>

<pre><code class="language-c++">StringPool Strings;                 // Create a new string pool

Strings.Set(0, &quot;Hey&quot;);              // Inserts string &quot;Hey&quot; at index 0
Strings.Set(2, &quot;World&quot;);            // Inserts string &quot;World&quot; at index 2
Strings.Set(0, &quot;Hi&quot;);               // Reassigns index 0 to the string &quot;Hi&quot;

Strings.Get(0);                     // Returns &quot;Hi&quot;
Strings.Get(1);                     // Returns &quot;&quot;
Strings.Get(2);                     // Returns &quot;World&quot;

Strings.Concatenate(0, &quot; Rio&quot;);
Strings.Get(0);                     // Returns &quot;Hi Rio&quot;
</code></pre>

<p>So let&rsquo;s begin by taking a look at the class declaration. Don&rsquo;t worry too much about what the individual variables and functions mean, as we&rsquo;ll be going over each one in detail. This is just meant to give a general idea of the layout of the class.</p>

<pre><code class="language-c++">class StringPool
{
public:
    StringPool();
    ~StringPool();
    void Set(int Index, const char * String); // Insert a string
    const char * Get(int Index); // Access a string
    void Concatenate(int Index, const char * String); // Concatenate strings
private:
    void ReserveNum(unsigned int Size); // Increase size of the offsets buffer
    void ReserveBuf(unsigned int Size); // Increase size of the strings buffer
    char * Allocate(int Index, unsigned int Strlen); // Allocate space for a new string
    unsigned int Len(int Index); // Returns the length of a string

    char * Buffer; // Memory block to store strings
    char * OldBuffer; // Copy of old buffer for copying strings
    unsigned int * Offsets; // Offsets to strings
    unsigned int BufferSize; // Size of the buffer
    unsigned int OffsetsSize; // Size of the offsets block
    unsigned int DataSize; // Size of the used part of the buffer, including garbage
    unsigned int GarbageSize; // Size of the garbage part of the buffer
    unsigned int Top; // Highest used offset
    int Num; // Number of strings in the pool

    enum DefineSizes 
    {
        AllocateSpaceBuffer = 4096, // Minimum size of the string buffer
        AllocateSpaceOffsets = 1024, // Minimum size of the offsets buffer
    };
};
</code></pre>

<p>The most important field of the <code>StringPool</code> class is <code>Buffer</code>. This is the memory block we&rsquo;ll use to store the strings and their length. This block should hold a minimum of <code>4096</code> characters, as defined in <code>AllocateSpaceBuffer</code>. Similarly, the <code>Offsets</code> buffer holds the offset in <code>Buffer</code> for each string. It should hold at least <code>1024</code> integer values, as specified in <code>AllocateSpaceOffsets</code>.</p>

<p>The <code>private</code> member functions <code>ReserveNum</code>, <code>ReserveBuf</code>, <code>Allocate</code> and <code>Len</code> are auxiliary. We&rsquo;ll be going into more detail for each one later in this section. For all the other fields a brief explanaition is provided in the form of a comment.</p>

<p>The <code>public</code> member functions <code>Set</code>, <code>Get</code> and <code>Concatenate</code> provide the class interface, as they allow us to manipulate strings in the pool. They are the ones we&rsquo;ll go through first.</p>

<p>But before that, let&rsquo;s take a look at the constructor and the desctructor. They are both very simple, so there is no need to go into much detail for either of them. In the constructor, we just set everything to zero. In the destructor we free the memory blocks allocated for the strings buffer and for the offsets buffer and set everything back to zero.</p>

<pre><code class="language-c++">StringPool::StringPool() 
{
    memset(this, 0, sizeof(*this));
}

StringPool::~StringPool()
{
    if (Buffer) delete[] Buffer;
    if (OldBuffer) delete[] OldBuffer;
    if (Offsets) delete[] Offsets;
    memset(this, 0, sizeof(*this));
}
</code></pre>

<p>Now that that is out of the way, let&rsquo;s go through the <code>Set</code> function, meant to insert a string into the pool. Inserting a string into the <code>StringPool</code> involves two steps: copying the string to the strings buffer along with it&rsquo;s length and setting the appropriate offset value in the offsets buffer. Of course, a few checks must be made to check whether the offsets buffer can hold another value, or if the strings buffer can hold the new string. If either is at capacity, then space for the new string must be made by increasing their size.</p>

<pre><code class="language-c++">void
StringPool::Set(int Index, const char * String)
{
    if (Index &lt; 0) return;

    // If the Index is higher than the any previous index
    // that means we are inserting a new string into the pool
    if (Index &gt;= Num)
    {
        // Update the number of strings in the pool
        Num = Index + 1;
        // If the index doesn't fit in the Offsets buffer we must increase it's size
        if ((unsigned int)Index &gt;= OffsetsSize)
        {
            ReserveNum(Index + 1);
        }
    }
    size_t Strlen = 0;
    if (String) Strlen = strlen(String);
    // If the length of the new string is zero
    if (Strlen == 0)
    {
        // And there was a string associated with Index
        if (Offsets[Index])
        {
            // We clear the string
            Offsets[Index] = 0;
            GarbageSize += Len(Index) + 1 + sizeof(unsigned int);
        }
        return;
    }

    // Otherwise we make space for and store the new string    
    char * AddressInBuffer = Allocate(Index, Strlen);
    // The length of the string is stored in the first four bytes
    *(unsigned int *)AddressInBuffer = (unsigned int)Strlen;
    memcpy(AddressInBuffer + sizeof(unsigned int), String, Strlen + 1);

    if (OldBuffer)
    {
        delete[] OldBuffer;
        OldBuffer = 0;
    }
}
</code></pre>

<p>The <code>Set</code> function makes use of two others that we have as not seen as of yet. Those are <code>ReserveNum</code> and <code>Allocate</code>. For now it&rsquo;s enough to know that <code>ReserveNum</code> increases the number of string offsets that the <code>Offsets</code> buffer can hold, and <code>Allocate</code> makes space for the new string, increasing the size of <code>Buffer</code> if necessary. We&rsquo;ll be going through their implementations in a bit.</p>

<p>Inserting a string is not very useful unless we can access it later. That is what <code>Get</code> is for. The process of fetching a string from the <code>StringPool</code> is very simple. All we need to do is figure out the string&rsquo;s position by taking it&rsquo;s offset from the offsets buffer and adding it to the strings buffer base address and that will give us the address of the string we are looking for. However we must not forget that the first four bytes of each string hold it&rsquo;s size, so in reality the actual content of the string begins four bytes after the string&rsquo;s address.</p>

<pre><code class="language-c++">const char *
StringPool::Get(int Index)
{
    if ((unsigned int)Index &lt; (unsigned int)Num)
    {
        // The first four bytes are skipped, as they hold the string length
        return Buffer + sizeof(unsigned int) + Offsets[Index];
    }
    return NULL;
}
</code></pre>

<p>We would also like to be able to do very simple string manipulation, and probably the simplest is concatenation. In order to concatenate two strings, we must first find a suitable space for the concatenated string in the <code>Buffer</code>. Sometimes this may be the position of the original string, in which case all that needs to be done is copying the string we want to append to the place immediatly after the original string&rsquo;s last character. But if that is not the case, then the whole concatenated string must be placed at the top of the <code>Buffer</code> and the offset must be updated accordingly.</p>

<pre><code class="language-c++">void
StringPool::Concatenate(int Index, const char * String)
{
    unsigned int Len1 = Len(Index);
    size_t Len2 = 0;

    if (String) Len2 = strlen(String);
    if (Len2 == 0) return;

    if (Index &gt;= Num) return;

    // If the original string is the empty string, just insert the new string
    if (Len1 == 0)
    {
        Set(Index, String);
        return;
    }

    const char * String1 = Get(Index);

    // Store the address of the original string
    char * PreviousAddress = Buffer + Offsets[Index];
    // Make space for the concatenated string
    char * AddressInBuffer = Allocate(Index, Len1 + Len2);

    // Set the lenght of the concatenated string
    *(unsigned int *)AddressInBuffer = (unsigned int)(Len1 + Len2);
    // If the concatenated string does not fit in the original's position     
    if (PreviousAddress != AddressInBuffer) 
    {
        // Copy original string to new position
        memcpy(AddressInBuffer + sizeof(unsigned int), String1, Len1);
    }
    // Copy the other string to the appropriate position
    memcpy(AddressInBuffer + sizeof(unsigned int) + Len1, String, Len2 + 1);

    if (OldBuffer)
    {
        delete[] OldBuffer;
        OldBuffer = 0;
    }
}
</code></pre>

<p>We have gone through the interface functions of the class. By this, I mean that if all you wanted to do was use the <code>StringPool</code> class to store and manipulate your strings, then those three functions would be all you needed to keep in mind.</p>

<p>Now it&rsquo;s time to look at the <code>private</code> auxiliary functions. We&rsquo;ll be looking at <code>Len</code> first. It&rsquo;s purpose is to find out the length of the string and it does that by looking at the number held in the first four bytes of the string in the strings buffer.</p>

<pre><code class="language-c++">unsigned int
StringPool::Len(int Index)
{
    if (Index &lt; Num)
    {
        // Cast the address of the string to unsigned int to find the length
	return *(unsigned int *)(Buffer + Offsets[Index]);
    }
    return 0;
}
</code></pre>

<p>When trying to allocate a string to a number that is larger than the current <code>OffsetSize</code> the capacity of the <code>Offsets</code> buffer must be increased. The question is then how much larger should it become? Obviously it needs to increase in size as much as necessary to accomodate the newly inserted index. But other than that we must consider that if we increase the size by too little we risk having to increase the buffer&rsquo;s size again very soon, and that is expensive. On the other hand, if we increase the size too much we migth waste a lot of space. The compromise reached in the implementation of <code>ReserveNum</code> is to increase the size to more than double the current value.</p>

<pre><code class="language-c++">
void
StringPool::ReserveNum(unsigned int Size)
{
    if (Size &lt; OffsetsSize) return;

    // Make sure the new size is at least double the current size
    if (Size &lt; OffsetsSize * 2 + AllocateSpaceOffsets)
    {
	Size = OffsetsSize * 2 + AllocateSpaceOffsets;
    }

    // Allocate the new offsets buffer
    unsigned int * Offsets2 = new unsigned int[Size];

    // Copy the old buffer contents to the new buffer
    if (Offsets) memcpy(Offsets2, Offsets, OffsetsSize * sizeof(*Offsets));
    // Set all the remaining positions to zero
    memset(Offsets2 + OffsetsSize, 0, (Size - OffsetsSize) * sizeof(*Offsets2));

    // Delete the old offsets buffer
    if (Offsets) delete[] Offsets;

    Offsets = Offsets2;
    OffsetsSize = Size;
}
</code></pre>

<p>We&rsquo;ve seen before that when inserting a string in the pool we must first find a space in the memory block where it will fit. That is what <code>Allocate</code> is for. The simplest case is when trying to insert a string identified by a number that has not been used before. In that case all that we need to do is to make sure that there is enough space at the top of the buffer to insert the string, and if there is not then make some space for it.</p>

<p>But if the number has been used (we are reassigning the number to another string) it may not be so simple. First we should check if there is enough space in the position of the old string to hold the new one. If there is then that space can be reused, and the offset value for that number remains the same. But if there isn&rsquo;t then space must be made at the top of the buffer and the offset value must be updated accordingly. Additionaly, the string that was previously associated with the number should be marked as trash.</p>

<pre><code class="language-c++">char *
StringPool::Allocate(int Index, unsigned int Strlen)
{
    // If the index has been used previously
    if (Offsets[Index])
    {
        // If it is the highest used index so far
	if (Offsets[Index] == Top)
	{
	    // Make space for the string at the top of the buffer
            if (Top + sizeof(unsigned int) + Strlen + 1 &gt; BufferSize)
	    {
		ReserveBuf(Top + sizeof(unsigned int) + Strlen + 1);
	    }
	    DataSize = Top + sizeof(unsigned int) + Strlen + 1;
	    return Buffer + Top;
	}
	// Reuse the space taken by the old string if possible
	unsigned int OldLen = Len(Index);
	if (OldLen &gt;= Strlen)
	{
	    GarbageSize += OldLen - Strlen;
	    return Buffer + Offsets[Index];
	}
	GarbageSize += OldLen + sizeof(unsigned int) + 1;
    }
    // Otherwise make space for the string at the top of the buffer
    if (DataSize + sizeof(unsigned int) + Strlen + 1 &gt; BufferSize)
    {
	ReserveBuf(DataSize + sizeof(unsigned int) + Strlen + 1);
    }
    Offsets[Index] = Top = DataSize;
    DataSize += sizeof(unsigned int) + Strlen + 1;
    return Buffer + Top;
}
</code></pre>

<p>When the strings buffer runs out of space it&rsquo;s size needs to be increased. That is done by calling <code>ReserveBuf</code>. As with <code>ReserveNum</code> the amount by which to increase the buffer size must be carefully considered. And again we opt by at least doubling the size every time we need to resize the <code>Buffer</code>.</p>

<pre><code class="language-c++">void
StringPool::ReserveBuf(unsigned int Size)
{
    // Make sure that the new size is at least double the old size
    if (Size &lt; (DataSize - GarbageSize) * 2 + AllocateSpaceBuffer)
    {
	Size = (DataSize - GarbageSize) * 2 + AllocateSpaceBuffer;
    }

    // Create the new buffer
    char * Buffer2 = new char[Size + sizeof(unsigned int) + 1];
    // Make the first position in the buffer the empty string
    *(unsigned int *)Buffer2 = 0;
    Buffer2[sizeof(unsigned int)] = 0;
    int DataSize2 = Top = sizeof(unsigned int) + 1;

    // Copy the old buffer into the new buffer
    if (Buffer)
    {
	for (int i = 0; i &lt; Num; i++)
	{
            if (Offsets[i])
	    {
	        unsigned int Strlen = Len(i);
 	        if (Strlen)
	        {
		    memcpy(Buffer2 + DataSize2,
		           Buffer + Offsets[i],
			   Strlen + sizeof(unsigned int) + 1);
		    Offsets[i] = Top = DataSize2;
		    DataSize2 += Strlen + sizeof(unsigned int) + 1;
	        }
	        else
	        {
		    Offsets[i] = 0;
		    GarbageSize += sizeof(unsigned int) + 1;
	        }
	    }
        }
	// Save the old buffer in case some strings are being copied
        OldBuffer = Buffer;
    }

    // Save the new buffer
    Buffer = Buffer2;
    BufferSize = Size + sizeof(unsigned int) + 1;

    DataSize = DataSize2;
    GarbageSize = 0;
}
</code></pre>

<p>And that is all there is to the implementation. I&rsquo;ve deliberately kept it very simple, but there are a lot of ways to improve it. We could, for instance, overload the assignment operator so that we could insert strings without calling <code>Set</code>. Like I&rsquo;ve mentioned before, if you are looking for a safer and more complete version of a <code>StringPool</code> go check the <a href="http://www.agner.org/optimize/optimizing_cpp.pdf"><em>&ldquo;Optimizing Software in C++&rdquo;</em></a> manual for the examples that come with it.</p>

<h2 id="benchmarks">Benchmarks</h2>

<p>We&rsquo;ve been through the teorethical speed improvements that a memory pool for strings provide over the standard <code>std::string</code>, but now it&rsquo;s time to put that to the test and see if they hold up in practice. The benchmarks we&rsquo;ll be focusing on are not super strict and rigourous, but they are enough to give us an ideia of the differences in speed between the implementations. Furthermore, we&rsquo;ll only be focusing on how fast the code is executed, and not on other factors like memory usage.</p>

<p>So let&rsquo;s begin by testing the assignment speed. We expect <code>std::string</code> to be slower because it is necessary to allocate space for each string individually, while the <code>StringPool</code> allocates space for many strings at once. To test this we&rsquo;ll be assigning one million <code>std::string</code> and then inserting one million strings into the pool.</p>

<pre><code class="language-c++">auto begin = std::chrono::system_clock::now();
for (int i = 0; i &lt; 1000000; i++)
{
    std::string Str = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;
}
auto end = std::chrono::system_clock::now();
printf(&quot;\tstd::string took %f seconds\n&quot;, std::chrono::duration&lt;double&gt;(end - begin).count());

begin = std::chrono::system_clock::now();
StringPool Strings;
for (int i = 0; i &lt; 1000000; i++)
{
    Strings.Set(i, &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;);
}
end = std::chrono::system_clock::now();
printf(&quot;\tStringPool took %f seconds\n&quot;, std::chrono::duration&lt;double&gt;(end - begin).count());
</code></pre>

<p>On my machine it takes <code>5.707221</code> seconds to allocate one million <code>std::strings</code>, while it only takes <code>0.189685</code> seconds to insert a million strings into the <code>StringPool</code>. This means that using memory pool is roughly 30 times faster than the alternative, which is a significant improvement.</p>

<p>Now let&rsquo;s take a look at the difference in speed for string concatenation. Again we expect the <code>StringPool</code> to be faster because of the reduced number of allocations, at the expense of potentially a lot of wasted memory. In order to test this we&rsquo;ll be using the <code>+=</code> operator to concatenate <code>std::strings</code> since it avoids allocating a new string to hold the result of the concatenation, and thus is faster than the <code>+</code> operator.</p>

<pre><code class="language-c++">auto begin = std::chrono::system_clock::now();
std::string Str = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;
for (int i = 0; i &lt; 1000000; i++)
{
    Str += &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;
}
auto end = std::chrono::system_clock::now();
printf(&quot;\tstd::string took %f seconds\n&quot;, std::chrono::duration&lt;double&gt;(end - begin).count());

begin = std::chrono::system_clock::now();
StringPool Strings;
Strings.Set(0, &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;);
for (int i = 0; i &lt; 1000000; i++)
{
    Strings.Concatenate(0, &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;);
}
end = std::chrono::system_clock::now();
printf(&quot;\tStringPool took %f seconds\n&quot;, std::chrono::duration&lt;double&gt;(end - begin).count());
</code></pre>

<p>It takes <code>1.114395</code> seconds on my machine to concatenate the <code>std::strings</code>, but only <code>0.197553</code> to concatenate the strings in the <code>StringPool</code>. This means that the memory pool in this case is about 5.5 times faster. Altough not as drastic an speed up as in the allocation case, it is still much faster. However, it is important to note that this is the best case for the <code>StringPool</code> because the string that we are appending to is at the top of the buffer and can freely grow until the buffer runs out of space, at which point it&rsquo;s size is increased and the string is copied over to the top of the new buffer. If this was not the case, the original string would need to be copied over to a new position in the buffer where the concatenated string would fit, slowing down the process a little bit.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We&rsquo;ve seen that allocating a memory block and managing it ourselves may speed up our program dramatically, at the cost of programming time and added complexity. So, while memory pools can be a powerful thing, the decision to use them should take into account a number of factors like the amount of objects we are dealing with and the necessity for performance of the program. In programs dealing with small amounts of objects the speed up is negligeble, and thus there are probably better ways to optimize our code for speed. In the end, it is just another tool  that we should be aware of so we can use it in the appropriate situations.</p>

<p>The source code for this post can be found <a href="https://gist.github.com/joaosilva22/b66337b41487ee11827f17cedca7fe40">here</a>.</p>

	<nav>
	
	
	</nav>
</article>
			<hr class="sep" />
		</main>
		<footer class="container">
			<div class="u-footer">
				
<a href="mailto:j.pedro004@gmail.com"><img class="icon-social" src="/img/email.svg" alt="Email Me!"/></a>


<a href="https://github.com/joaosilva22/"><img class="icon-social" src="/img/github.svg" alt="Github"/></a>


<a href="https://twitter.com/joaopsilva22"><img class="icon-social" src="/img/twitter.svg" alt="Twitter"/></a>

<a href="https://joaosilva22.github.io/index.xml" target="_blank"><img class="icon-social" src="/img/feed.svg" alt="Feed"></a>

				<p>
					
					Theme used: <a href="https://github.com/yursan9/manis-hugo-theme">Manis</a><br>
					
					
					&copy; 2017 João Pedro Silva
					
					
				</p>
				
				<a href="#">
					<img class="icon-text" src="/img/toup.svg" alt="To Up"/>
					<span>Back to Up</span>
				</a>
				
			</div>
		</footer>
		
		<script>hljs.initHighlightingOnLoad();</script>
		
	</body>
</html>

